"""
Logica C Transpiler — AST to C
===============================

Takes a Logica AST (after axiom checking) and emits C code
that links against the Mary C kernel runtime.

The transpiled output + mary.h + mary.c is standalone.
Compile with: clang -o program mary.c program.c
Or to WASM:   clang --target=wasm32-wasi -o program.wasm mary.c program.c

Pipeline:
    .logica source -> Lexer -> Parser -> Compiler (axiom check) -> CTranspiler -> .c
"""

import json

from .ast_nodes import *


class CTranspiler:
    """
    Walks the Logica AST and emits C code.

    The output includes:
    1. #include directives and forward declarations
    2. The transpiled program code inside main()
    3. A summary footer (ledger stats)
    """

    def __init__(self):
        self.indent = 0
        self.lines = []
        self.current_speaker = None
        self.declared_speakers = set()
        self.temp_counter = 0
        self.functions = []  # (speaker, name, params, body) tuples
        self.string_bufs = 0  # counter for snprintf temp buffers

    def transpile(self, ast: Program) -> str:
        """Transpile a Logica AST to self-contained C source."""
        # First pass: collect declared speakers and functions
        for stmt in ast.statements:
            if isinstance(stmt, SpeakerDecl):
                self.declared_speakers.add(stmt.name)
        self._collect_functions(ast.statements)

        # Generate code
        self.lines = []
        self._emit("/* ================================================================ */")
        self._emit("/* Generated by Logica C Transpiler                                */")
        self._emit("/* A Programming Language for Human Logic                           */")
        self._emit("/* ================================================================ */")
        self._emit("")
        self._emit('#include "mary.h"')
        self._emit("#include <stdio.h>")
        self._emit("#include <string.h>")
        self._emit("#include <math.h>")
        self._emit("")

        # Forward-declare functions
        for speaker, name, params, body in self.functions:
            param_decl = ", ".join(["Mary* _m", "int _sid"] +
                                   [f"double _p_{p}" for p in params])
            self._emit(f"static double fn_{speaker}_{name}({param_decl});")
        if self.functions:
            self._emit("")

        # Static Mary instance (too large for stack)
        self._emit("static Mary _mary;")
        self._emit("")

        # Emit function definitions
        for speaker, name, params, body in self.functions:
            self._emit_function_def(speaker, name, params, body)

        # Emit main
        self._emit("int main(void) {")
        self.indent += 1
        self._emit("mary_init(&_mary);")
        self._emit("")

        # Speaker declarations
        for stmt in ast.statements:
            if isinstance(stmt, SpeakerDecl):
                safe = self._safe_name(stmt.name)
                self._emit(f'int Speaker_{safe} = mary_create_speaker(&_mary, 0, "{stmt.name}");')
        self._emit("")

        # Speaker name tracking (for speak output)
        self._emit("const char* _speaker_name = \"\";")
        self._emit("int _current_sid = 0;")
        self._emit("")

        for stmt in ast.statements:
            self._transpile_statement(stmt)

        # Summary footer
        self._emit("")
        self._emit("/* -- Summary -- */")
        self._emit("printf(\"\\n\");")
        self._emit('printf("  ---\\n");')
        self._emit('printf("  ledger: %d entries, integrity: %s\\n",')
        self._emit('       mary_ledger_count(&_mary),')
        self._emit('       mary_ledger_verify(&_mary) ? "VALID" : "BROKEN");')
        self._emit('printf("  speakers: [");')

        # Print speaker names
        speaker_list = sorted(self.declared_speakers)
        for i, name in enumerate(speaker_list):
            if i > 0:
                self._emit(f'printf(", \\"{name}\\"");')
            else:
                self._emit(f'printf("\\"{name}\\"");')
        self._emit('printf("]\\n");')
        self._emit('printf("  ---\\n");')

        self._emit("")
        self._emit("return 0;")
        self.indent -= 1
        self._emit("}")
        self._emit("")

        return "\n".join(self.lines) + "\n"

    # -- Code Emission -------------------------------------------------

    def _emit(self, line):
        """Emit a line of C code at the current indentation."""
        if line == "":
            self.lines.append("")
        else:
            self.lines.append("    " * self.indent + line)

    def _safe_name(self, name):
        """Make a name safe for C identifiers."""
        return name.replace(" ", "_").replace(".", "_").replace("-", "_")

    def _next_temp(self):
        """Generate a unique temporary variable name."""
        t = f"_tmp{self.temp_counter}"
        self.temp_counter += 1
        return t

    def _next_strbuf(self):
        """Generate a unique string buffer variable name."""
        t = f"_sbuf{self.string_bufs}"
        self.string_bufs += 1
        return t

    # -- Function Collection -------------------------------------------

    def _collect_functions(self, stmts, speaker=None):
        """Pre-collect all function declarations from the AST."""
        for stmt in stmts:
            if isinstance(stmt, AsBlock):
                self._collect_functions(stmt.body, stmt.speaker_name)
            elif isinstance(stmt, FnDecl) and speaker:
                self.functions.append((speaker, stmt.name, stmt.params, stmt.body))

    # -- Statement Transpilation ----------------------------------------

    def _transpile_statement(self, stmt):
        """Transpile a single AST statement to C."""
        if isinstance(stmt, SpeakerDecl):
            pass  # Already handled above

        elif isinstance(stmt, AsBlock):
            self._transpile_as_block(stmt)

        elif isinstance(stmt, LetStatement):
            self._transpile_let(stmt)

        elif isinstance(stmt, SpeakStatement):
            self._transpile_speak(stmt)

        elif isinstance(stmt, WhenBlock):
            self._transpile_when(stmt)

        elif isinstance(stmt, IfStatement):
            self._transpile_if(stmt)

        elif isinstance(stmt, WhileLoop):
            self._transpile_while(stmt)

        elif isinstance(stmt, FnDecl):
            pass  # Handled separately as top-level function defs

        elif isinstance(stmt, ReturnStatement):
            if stmt.value:
                self._emit(f"return {self._expr_num(stmt.value)};")
            else:
                self._emit("return 0.0;")

        elif isinstance(stmt, RequestStatement):
            action = self._expr_as_str(stmt.action)
            safe_target = self._safe_name(stmt.target)
            self._emit("{")
            self.indent += 1
            self._emit(f"char _req_action[256];")
            self._emit(f"snprintf(_req_action, sizeof(_req_action), \"%s\", {action});")
            self._emit(f"mary_request(&_mary, _current_sid, Speaker_{safe_target}, _req_action);")
            self._emit(f'printf("  [%s] request -> {stmt.target}: %s\\n", _speaker_name, _req_action);')
            self.indent -= 1
            self._emit("}")

        elif isinstance(stmt, RespondStatement):
            accept_str = "1" if stmt.accept else "0"
            action_word = "accepted" if stmt.accept else "refused"
            self._emit("{")
            self.indent += 1
            self._emit("/* Find first pending request for this speaker */")
            self._emit("int _req_found = 0;")
            self._emit("for (int _ri = 0; _ri < _mary.request_count; _ri++) {")
            self.indent += 1
            self._emit("if (_mary.requests[_ri].to_speaker == _current_sid &&")
            self._emit("    _mary.requests[_ri].status == MARY_REQ_PENDING) {")
            self.indent += 1
            self._emit(f"mary_respond(&_mary, _current_sid, _mary.requests[_ri].request_id, {accept_str});")
            self._emit(f'printf("  [%s] {action_word} request #%d\\n", _speaker_name, _mary.requests[_ri].request_id);')
            self._emit("_req_found = 1;")
            self._emit("break;")
            self.indent -= 1
            self._emit("}")
            self.indent -= 1
            self._emit("}")
            self.indent -= 1
            self._emit("}")

        elif isinstance(stmt, InspectStatement):
            self._transpile_inspect(stmt)

        elif isinstance(stmt, HistoryStatement):
            self._transpile_history(stmt)

        elif isinstance(stmt, LedgerStatement):
            self._transpile_ledger(stmt)

        elif isinstance(stmt, VerifyStatement):
            self._emit('printf("  ledger integrity: %s\\n", mary_ledger_verify(&_mary) ? "VALID" : "BROKEN");')

        elif isinstance(stmt, SealStatement):
            self._emit(f'mary_seal(&_mary, _current_sid, "{stmt.target}");')
            self._emit(f'printf("  [%s] sealed: {stmt.target}\\n", _speaker_name);')

        elif isinstance(stmt, PassStatement):
            self._emit("/* pass */")

        elif isinstance(stmt, FailStatement):
            if stmt.reason:
                reason = self._expr_as_str(stmt.reason)
                self._emit("{")
                self.indent += 1
                self._emit(f'fprintf(stderr, "FAIL: %s\\n", {reason});')
                self._emit("return 1;")
                self.indent -= 1
                self._emit("}")
            else:
                self._emit('fprintf(stderr, "FAIL: explicit fail\\n");')
                self._emit("return 1;")

        elif isinstance(stmt, ExpressionStatement):
            self._emit(f"{self._expr_num(stmt.expression)};")

        elif isinstance(stmt, WorldDecl):
            self._emit(f'printf("  [%s] world created: {stmt.name}\\n", _speaker_name);')

    # -- Block Transpilation --------------------------------------------

    def _transpile_as_block(self, stmt):
        """Transpile 'as Speaker { ... }' block."""
        prev = self.current_speaker
        self.current_speaker = stmt.speaker_name
        safe = self._safe_name(stmt.speaker_name)
        self._emit("")
        self._emit(f"/* as {stmt.speaker_name} */")
        self._emit(f'_speaker_name = "{stmt.speaker_name}";')
        self._emit(f"_current_sid = Speaker_{safe};")

        for s in stmt.body:
            self._transpile_statement(s)

        self.current_speaker = prev
        if prev:
            safe_prev = self._safe_name(prev)
            self._emit(f'_speaker_name = "{prev}";')
            self._emit(f"_current_sid = Speaker_{safe_prev};")

    def _transpile_let(self, stmt):
        """Transpile 'let name = expr'."""
        vtype = self._infer_type(stmt.value)

        if vtype == "str":
            val = self._expr_as_str(stmt.value)
            self._emit("{")
            self.indent += 1
            self._emit(f"char _letval[256];")
            self._emit(f"snprintf(_letval, sizeof(_letval), \"%s\", {val});")
            self._emit(f'mary_write_str(&_mary, _current_sid, "{stmt.name}", _letval);')
            self.indent -= 1
            self._emit("}")
        else:
            val = self._expr_num(stmt.value)
            self._emit(f'mary_write(&_mary, _current_sid, "{stmt.name}", (double)({val}));')

    def _transpile_speak(self, stmt):
        """Transpile 'speak expr'."""
        vtype = self._infer_type(stmt.value)

        if vtype == "str":
            val = self._expr_as_str(stmt.value)
            self._emit("{")
            self.indent += 1
            self._emit(f'char _spk[512];')
            self._emit(f'snprintf(_spk, sizeof(_spk), "%s", {val});')
            self._emit(f'printf("  [%s] %s\\n", _speaker_name, _spk);')
            self._emit(f'mary_ledger_append(&_mary, _current_sid, "speak", _spk, MARY_STATUS_ACTIVE);')
            self.indent -= 1
            self._emit("}")
        elif vtype == "num":
            val = self._expr_num(stmt.value)
            self._emit("{")
            self.indent += 1
            self._emit(f"double _spkv = {val};")
            self._emit(f'if (_spkv == (int)_spkv)')
            self._emit(f'    printf("  [%s] %d\\n", _speaker_name, (int)_spkv);')
            self._emit(f"else")
            self._emit(f'    printf("  [%s] %g\\n", _speaker_name, _spkv);')
            self._emit(f'char _spk_action[256];')
            self._emit(f'snprintf(_spk_action, sizeof(_spk_action), "speak:%g", _spkv);')
            self._emit(f'mary_ledger_append(&_mary, _current_sid, "speak", _spk_action, MARY_STATUS_ACTIVE);')
            self.indent -= 1
            self._emit("}")
        else:
            # Unknown type — try as string
            val = self._expr_as_str(stmt.value)
            self._emit("{")
            self.indent += 1
            self._emit(f'printf("  [%s] %s\\n", _speaker_name, {val});')
            self._emit(f'mary_ledger_append(&_mary, _current_sid, "speak", {val}, MARY_STATUS_ACTIVE);')
            self.indent -= 1
            self._emit("}")

    def _transpile_when(self, stmt):
        """
        Transpile three-valued when/otherwise/broken block.
        """
        cond = self._expr_num(stmt.condition)
        self._emit("/* when block (three-valued) */")
        self._emit("{")
        self.indent += 1

        self._emit(f"int _cond_met = (int)({cond});")

        self._emit("if (_cond_met) {")
        self.indent += 1
        for s in stmt.body:
            self._transpile_statement(s)
        self.indent -= 1

        if stmt.otherwise_body:
            self._emit("} else {")
            self.indent += 1
            for s in stmt.otherwise_body:
                self._transpile_statement(s)
            self.indent -= 1

        self._emit("}")

        self.indent -= 1
        self._emit("}")

    def _transpile_if(self, stmt):
        """Transpile if/elif/else."""
        cond = self._expr_num(stmt.condition)
        self._emit(f"if ((int)({cond})) {{")
        self.indent += 1
        for s in stmt.body:
            self._transpile_statement(s)
        self.indent -= 1

        for clause in stmt.elif_clauses:
            clause_cond = self._expr_num(clause.condition)
            self._emit(f"}} else if ((int)({clause_cond})) {{")
            self.indent += 1
            for s in clause.body:
                self._transpile_statement(s)
            self.indent -= 1

        if stmt.else_body:
            self._emit("} else {")
            self.indent += 1
            for s in stmt.else_body:
                self._transpile_statement(s)
            self.indent -= 1

        self._emit("}")

    def _transpile_while(self, stmt):
        """Transpile bounded while loop. Axiom 9: every loop has a max bound."""
        cond = self._expr_num(stmt.condition)
        max_iter = self._expr_num(stmt.max_iterations) if stmt.max_iterations else "10000"

        self._emit("{")
        self.indent += 1
        self._emit(f"int _maxIter = (int)({max_iter});")
        self._emit("int _loopCount = 0;")
        self._emit(f"while ((int)({cond}) && _loopCount < _maxIter) {{")
        self.indent += 1
        for s in stmt.body:
            self._transpile_statement(s)
        self._emit("_loopCount++;")
        self.indent -= 1
        self._emit("}")
        self.indent -= 1
        self._emit("}")

    def _transpile_inspect(self, stmt):
        """Transpile inspect statement."""
        target = stmt.target
        if isinstance(target, Identifier):
            name = target.name
            if name in self.declared_speakers:
                safe = self._safe_name(name)
                self._emit(f"mary_inspect_speaker(&_mary, _current_sid, Speaker_{safe});")
            else:
                self._emit(f'printf("  --- inspect %s ---\\n", "{name}");')
        elif isinstance(target, MemberAccess) and isinstance(target.object, Identifier):
            speaker_name = target.object.name
            var_name = target.member
            safe = self._safe_name(speaker_name)
            self._emit(f'mary_inspect_variable(&_mary, _current_sid, Speaker_{safe}, "{var_name}");')

    def _transpile_history(self, stmt):
        """Transpile history statement."""
        target = stmt.target
        if isinstance(target, MemberAccess) and isinstance(target.object, Identifier):
            speaker_name = target.object.name
            var_name = target.member
            safe = self._safe_name(speaker_name)
            self._emit(f'mary_inspect_variable(&_mary, _current_sid, Speaker_{safe}, "{var_name}");')
        elif isinstance(target, Identifier):
            self._emit(f'mary_inspect_variable(&_mary, _current_sid, _current_sid, "{target.name}");')

    def _transpile_ledger(self, stmt):
        """Transpile ledger statement."""
        self._emit("{")
        self.indent += 1
        self._emit("int _ltotal = mary_ledger_count(&_mary);")
        if stmt.count:
            count_expr = self._expr_num(stmt.count)
            self._emit(f"int _lcount = (int)({count_expr});")
            self._emit("if (_lcount > _ltotal) _lcount = _ltotal;")
        else:
            self._emit("int _lcount = _ltotal;")
        self._emit("int _lstart = _ltotal - _lcount;")
        self._emit("if (_lstart < 0) _lstart = 0;")
        self._emit('printf("  --- ledger (last %d of %d) ---\\n", _lcount, _ltotal);')
        self._emit("for (int _li = _lstart; _li < _ltotal; _li++) {")
        self.indent += 1
        self._emit('printf("    #%d [%8s] %s: %s\\n",')
        self._emit("       _mary.ledger[_li].entry_id,")
        self._emit('       _mary.ledger[_li].status == MARY_STATUS_ACTIVE ? "active" :')
        self._emit('       _mary.ledger[_li].status == MARY_STATUS_INACTIVE ? "inactive" :')
        self._emit('       _mary.ledger[_li].status == MARY_STATUS_BROKEN ? "broken" : "-",')
        self._emit("       mary_speaker_name(&_mary, _mary.ledger[_li].speaker_id),")
        self._emit("       _mary.ledger[_li].action);")
        self.indent -= 1
        self._emit("}")
        self._emit('printf("  ---\\n");')
        self.indent -= 1
        self._emit("}")

    # -- Function Definition Emission -----------------------------------

    def _emit_function_def(self, speaker, name, params, body):
        """Emit a top-level C function definition for a Logica fn."""
        param_decl = ", ".join(["Mary* _m", "int _sid"] +
                               [f"double _p_{p}" for p in params])
        self._emit(f"static double fn_{speaker}_{name}({param_decl}) {{")
        self.indent += 1

        # Write params to Mary memory so let/read inside fn works
        for p in params:
            self._emit(f'mary_write(_m, _sid, "{p}", _p_{p});')

        # Save context
        old_speaker = self.current_speaker
        self.current_speaker = speaker

        for stmt in body:
            self._transpile_fn_statement(stmt, params)

        self.current_speaker = old_speaker

        self._emit("return 0.0;")
        self.indent -= 1
        self._emit("}")
        self._emit("")

    def _transpile_fn_statement(self, stmt, params):
        """Transpile a statement inside a function body.
        Uses _m and _sid instead of &_mary and _current_sid."""
        if isinstance(stmt, LetStatement):
            vtype = self._infer_type(stmt.value)
            if vtype == "str":
                val = self._expr_as_str_fn(stmt.value, params)
                self._emit("{")
                self.indent += 1
                self._emit(f"char _letval[256];")
                self._emit(f"snprintf(_letval, sizeof(_letval), \"%s\", {val});")
                self._emit(f'mary_write_str(_m, _sid, "{stmt.name}", _letval);')
                self.indent -= 1
                self._emit("}")
            else:
                val = self._expr_num_fn(stmt.value, params)
                self._emit(f'mary_write(_m, _sid, "{stmt.name}", (double)({val}));')

        elif isinstance(stmt, ReturnStatement):
            if stmt.value:
                val = self._expr_num_fn(stmt.value, params)
                self._emit(f"return {val};")
            else:
                self._emit("return 0.0;")

        elif isinstance(stmt, IfStatement):
            cond = self._expr_num_fn(stmt.condition, params)
            self._emit(f"if ((int)({cond})) {{")
            self.indent += 1
            for s in stmt.body:
                self._transpile_fn_statement(s, params)
            self.indent -= 1

            for clause in stmt.elif_clauses:
                clause_cond = self._expr_num_fn(clause.condition, params)
                self._emit(f"}} else if ((int)({clause_cond})) {{")
                self.indent += 1
                for s in clause.body:
                    self._transpile_fn_statement(s, params)
                self.indent -= 1

            if stmt.else_body:
                self._emit("} else {")
                self.indent += 1
                for s in stmt.else_body:
                    self._transpile_fn_statement(s, params)
                self.indent -= 1

            self._emit("}")

        elif isinstance(stmt, WhileLoop):
            cond = self._expr_num_fn(stmt.condition, params)
            max_iter = self._expr_num_fn(stmt.max_iterations, params) if stmt.max_iterations else "10000"
            self._emit("{")
            self.indent += 1
            self._emit(f"int _maxIter = (int)({max_iter});")
            self._emit("int _loopCount = 0;")
            self._emit(f"while ((int)({cond}) && _loopCount < _maxIter) {{")
            self.indent += 1
            for s in stmt.body:
                self._transpile_fn_statement(s, params)
            self._emit("_loopCount++;")
            self.indent -= 1
            self._emit("}")
            self.indent -= 1
            self._emit("}")

        elif isinstance(stmt, SpeakStatement):
            vtype = self._infer_type(stmt.value)
            if vtype == "str":
                val = self._expr_as_str_fn(stmt.value, params)
                self._emit(f'printf("  [%s] %s\\n", mary_speaker_name(_m, _sid), {val});')
            else:
                val = self._expr_num_fn(stmt.value, params)
                self._emit("{")
                self.indent += 1
                self._emit(f"double _spkv = {val};")
                self._emit(f'if (_spkv == (int)_spkv)')
                self._emit(f'    printf("  [%s] %d\\n", mary_speaker_name(_m, _sid), (int)_spkv);')
                self._emit(f"else")
                self._emit(f'    printf("  [%s] %g\\n", mary_speaker_name(_m, _sid), _spkv);')
                self.indent -= 1
                self._emit("}")

        elif isinstance(stmt, WhenBlock):
            cond = self._expr_num_fn(stmt.condition, params)
            self._emit("{")
            self.indent += 1
            self._emit(f"int _cond_met = (int)({cond});")
            self._emit("if (_cond_met) {")
            self.indent += 1
            for s in stmt.body:
                self._transpile_fn_statement(s, params)
            self.indent -= 1
            if stmt.otherwise_body:
                self._emit("} else {")
                self.indent += 1
                for s in stmt.otherwise_body:
                    self._transpile_fn_statement(s, params)
                self.indent -= 1
            self._emit("}")
            self.indent -= 1
            self._emit("}")

        elif isinstance(stmt, PassStatement):
            self._emit("/* pass */")

    # -- Type Inference -------------------------------------------------

    def _infer_type(self, node):
        """Infer whether an expression is 'str', 'num', or 'unknown'."""
        if node is None:
            return "num"
        if isinstance(node, StringLiteral):
            return "str"
        if isinstance(node, (IntegerLiteral, FloatLiteral)):
            return "num"
        if isinstance(node, BooleanLiteral):
            return "num"
        if isinstance(node, NoneLiteral):
            return "num"
        if isinstance(node, StatusLiteral):
            return "str"
        if isinstance(node, BinaryOp):
            lt = self._infer_type(node.left)
            rt = self._infer_type(node.right)
            if lt == "str" or rt == "str":
                if node.op == "+":
                    return "str"  # string concatenation
                return "num"  # comparison returns num
            return "num"
        if isinstance(node, UnaryOp):
            return "num"
        if isinstance(node, FnCall):
            return "num"  # functions return double
        if isinstance(node, ReadExpr):
            return "unknown"
        if isinstance(node, MemberAccess):
            return "unknown"
        if isinstance(node, Identifier):
            return "unknown"
        if isinstance(node, ConditionalExpr):
            return self._infer_type(node.true_value)
        return "unknown"

    # -- Expression Transpilation (numeric context) ─────────────────────

    def _expr_num(self, node) -> str:
        """Transpile an expression to a C numeric expression string."""
        if node is None:
            return "0.0"

        if isinstance(node, IntegerLiteral):
            return f"{node.value}.0"

        if isinstance(node, FloatLiteral):
            return str(node.value)

        if isinstance(node, StringLiteral):
            return "0.0"

        if isinstance(node, BooleanLiteral):
            return "1.0" if node.value else "0.0"

        if isinstance(node, NoneLiteral):
            return "0.0"

        if isinstance(node, StatusLiteral):
            return "0.0"

        if isinstance(node, Identifier):
            return f'mary_read_num(&_mary, _current_sid, _current_sid, "{node.name}")'

        if isinstance(node, MemberAccess):
            return self._expr_member_num(node)

        if isinstance(node, BinaryOp):
            return self._expr_binary_num(node)

        if isinstance(node, UnaryOp):
            return self._expr_unary_num(node)

        if isinstance(node, FnCall):
            return self._expr_fn_call(node)

        if isinstance(node, ReadExpr):
            return self._expr_num(node.target)

        if isinstance(node, ConditionalExpr):
            cond = self._expr_num(node.condition)
            true_val = self._expr_num(node.true_value)
            false_val = self._expr_num(node.false_value)
            return f"((int)({cond}) ? {true_val} : {false_val})"

        if isinstance(node, IndexAccess):
            return "0.0"

        return "0.0"

    def _expr_member_num(self, node):
        """Transpile member access in numeric context."""
        if isinstance(node.object, Identifier):
            name = node.object.name
            if name in self.declared_speakers:
                safe = self._safe_name(name)
                return f'mary_read_num(&_mary, _current_sid, Speaker_{safe}, "{node.member}")'
            else:
                return f'mary_read_num(&_mary, _current_sid, _current_sid, "{name}")'
        return "0.0"

    def _expr_binary_num(self, node):
        """Transpile binary expression in numeric context."""
        # String concatenation case
        if node.op == "+":
            lt = self._infer_type(node.left)
            rt = self._infer_type(node.right)
            if lt == "str" or rt == "str":
                return "0.0"  # string concat not meaningful as number

        left = self._expr_num(node.left)
        right = self._expr_num(node.right)

        if node.op == '/':
            return f"({right} != 0.0 ? {left} / {right} : 0.0)"
        if node.op == '%':
            return f"({right} != 0.0 ? fmod({left}, {right}) : 0.0)"

        c_ops = {
            '+': '+', '-': '-', '*': '*',
            '==': '==', '!=': '!=',
            '<': '<', '>': '>', '<=': '<=', '>=': '>=',
            'and': '&&', 'or': '||',
        }
        c_op = c_ops.get(node.op, node.op)
        return f"({left} {c_op} {right})"

    def _expr_unary_num(self, node):
        """Transpile unary expression in numeric context."""
        operand = self._expr_num(node.operand)
        if node.op == 'not':
            return f"(!({operand}))"
        return f"({node.op}{operand})"

    def _expr_fn_call(self, node):
        """Transpile function call."""
        args_c = ", ".join(["&_mary", "_current_sid"] +
                           [self._expr_num(a) for a in node.args])

        if isinstance(node.function, Identifier):
            fn_name = node.function.name
            # Look up in declared functions
            for speaker, name, params, body in self.functions:
                if name == fn_name:
                    return f"fn_{speaker}_{name}({args_c})"
            # Try current speaker
            if self.current_speaker:
                return f"fn_{self._safe_name(self.current_speaker)}_{fn_name}({args_c})"
            return "0.0"

        if isinstance(node.function, MemberAccess):
            if isinstance(node.function.object, Identifier):
                speaker = node.function.object.name
                fn_name = node.function.member
                safe = self._safe_name(speaker)
                return f"fn_{safe}_{fn_name}({args_c})"

        return "0.0"

    # -- Expression Transpilation (string context) ──────────────────────

    def _expr_as_str(self, node) -> str:
        """Transpile an expression to a C string expression.
        Returns a (const char*) expression."""
        if node is None:
            return '""'

        if isinstance(node, StringLiteral):
            return self._c_string(node.value)

        if isinstance(node, IntegerLiteral):
            # Return as a string literal with the number
            return self._c_string(str(node.value))

        if isinstance(node, FloatLiteral):
            return self._c_string(str(node.value))

        if isinstance(node, BooleanLiteral):
            return self._c_string("true" if node.value else "false")

        if isinstance(node, NoneLiteral):
            return self._c_string("null")

        if isinstance(node, StatusLiteral):
            return self._c_string(node.value)

        if isinstance(node, Identifier):
            # Read as string from Mary
            return f'mary_read_str(&_mary, _current_sid, _current_sid, "{node.name}")'

        if isinstance(node, MemberAccess):
            return self._expr_member_str(node)

        if isinstance(node, ReadExpr):
            return self._expr_as_str(node.target)

        if isinstance(node, BinaryOp):
            if node.op == "+":
                lt = self._infer_type(node.left)
                rt = self._infer_type(node.right)
                if lt == "str" or rt == "str":
                    # String concatenation — not directly returnable as const char*
                    # Caller should use snprintf
                    return self._expr_as_str(node.left)
            # For comparisons, return as number converted to string
            return self._c_string("0")

        if isinstance(node, FnCall):
            return self._c_string("0")

        if isinstance(node, ConditionalExpr):
            cond = self._expr_num(node.condition)
            true_val = self._expr_as_str(node.true_value)
            false_val = self._expr_as_str(node.false_value)
            return f"((int)({cond}) ? {true_val} : {false_val})"

        return '""'

    def _expr_member_str(self, node):
        """Transpile member access in string context."""
        if isinstance(node.object, Identifier):
            name = node.object.name
            if name in self.declared_speakers:
                safe = self._safe_name(name)
                return f'mary_read_str(&_mary, _current_sid, Speaker_{safe}, "{node.member}")'
            else:
                return f'mary_read_str(&_mary, _current_sid, _current_sid, "{name}")'
        return '""'

    # -- Expression in Function Context ---------------------------------

    def _expr_num_fn(self, node, params) -> str:
        """Transpile expression to numeric in function context (uses _m, _sid)."""
        if node is None:
            return "0.0"
        if isinstance(node, IntegerLiteral):
            return f"{node.value}.0"
        if isinstance(node, FloatLiteral):
            return str(node.value)
        if isinstance(node, StringLiteral):
            return "0.0"
        if isinstance(node, BooleanLiteral):
            return "1.0" if node.value else "0.0"
        if isinstance(node, NoneLiteral):
            return "0.0"
        if isinstance(node, Identifier):
            if node.name in params:
                return f"mary_read_num(_m, _sid, _sid, \"{node.name}\")"
            return f'mary_read_num(_m, _sid, _sid, "{node.name}")'
        if isinstance(node, MemberAccess):
            if isinstance(node.object, Identifier):
                name = node.object.name
                if name in self.declared_speakers:
                    safe = self._safe_name(name)
                    return f'mary_read_num(_m, _sid, Speaker_{safe}, "{node.member}")'
            return "0.0"
        if isinstance(node, BinaryOp):
            left = self._expr_num_fn(node.left, params)
            right = self._expr_num_fn(node.right, params)
            if node.op == '/':
                return f"({right} != 0.0 ? {left} / {right} : 0.0)"
            if node.op == '%':
                return f"({right} != 0.0 ? fmod({left}, {right}) : 0.0)"
            c_ops = {
                '+': '+', '-': '-', '*': '*',
                '==': '==', '!=': '!=',
                '<': '<', '>': '>', '<=': '<=', '>=': '>=',
                'and': '&&', 'or': '||',
            }
            c_op = c_ops.get(node.op, node.op)
            return f"({left} {c_op} {right})"
        if isinstance(node, UnaryOp):
            operand = self._expr_num_fn(node.operand, params)
            if node.op == 'not':
                return f"(!({operand}))"
            return f"({node.op}{operand})"
        if isinstance(node, FnCall):
            args_c = ", ".join(["_m", "_sid"] +
                               [self._expr_num_fn(a, params) for a in node.args])
            if isinstance(node.function, Identifier):
                fn_name = node.function.name
                for speaker, fname, fparams, fbody in self.functions:
                    if fname == fn_name:
                        return f"fn_{speaker}_{fname}({args_c})"
                if self.current_speaker:
                    return f"fn_{self._safe_name(self.current_speaker)}_{fn_name}({args_c})"
            if isinstance(node.function, MemberAccess):
                if isinstance(node.function.object, Identifier):
                    speaker = node.function.object.name
                    fn_name = node.function.member
                    safe = self._safe_name(speaker)
                    return f"fn_{safe}_{fn_name}({args_c})"
            return "0.0"
        if isinstance(node, ReadExpr):
            return self._expr_num_fn(node.target, params)
        if isinstance(node, ConditionalExpr):
            cond = self._expr_num_fn(node.condition, params)
            true_val = self._expr_num_fn(node.true_value, params)
            false_val = self._expr_num_fn(node.false_value, params)
            return f"((int)({cond}) ? {true_val} : {false_val})"
        return "0.0"

    def _expr_as_str_fn(self, node, params) -> str:
        """Transpile expression to string in function context."""
        if node is None:
            return '""'
        if isinstance(node, StringLiteral):
            return self._c_string(node.value)
        if isinstance(node, Identifier):
            return f'mary_read_str(_m, _sid, _sid, "{node.name}")'
        if isinstance(node, MemberAccess):
            if isinstance(node.object, Identifier):
                name = node.object.name
                if name in self.declared_speakers:
                    safe = self._safe_name(name)
                    return f'mary_read_str(_m, _sid, Speaker_{safe}, "{node.member}")'
            return '""'
        if isinstance(node, ReadExpr):
            return self._expr_as_str_fn(node.target, params)
        return '""'

    # -- Helpers --------------------------------------------------------

    def _c_string(self, value):
        """Escape a Python string for C source code."""
        escaped = value.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n").replace("\t", "\\t")
        return f'"{escaped}"'
