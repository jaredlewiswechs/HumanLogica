"""
Logica JS Transpiler — AST to JavaScript
==========================================

Takes a Logica AST (after axiom checking) and emits JavaScript
that runs on Node.js with a self-contained Mary kernel runtime.

The transpiled output is standalone — no external dependencies.
Run it with: node output.js

Pipeline:
    .logica source → Lexer → Parser → Compiler (axiom check) → Transpiler → .js
"""

import os
import json

from .ast_nodes import *


class JSTranspiler:
    """
    Walks the Logica AST and emits JavaScript.

    The output includes:
    1. The JS runtime (Mary kernel, Context helper)
    2. The transpiled program code
    3. A summary footer (ledger stats)
    """

    def __init__(self):
        self.indent = 0
        self.lines = []
        self.current_speaker = None
        self.declared_speakers = set()

    def transpile(self, ast: Program) -> str:
        """Transpile a Logica AST to self-contained JavaScript."""
        # First pass: collect declared speakers
        for stmt in ast.statements:
            if isinstance(stmt, SpeakerDecl):
                self.declared_speakers.add(stmt.name)

        # Read the JS runtime
        runtime_path = os.path.join(os.path.dirname(__file__), 'js_runtime.js')
        with open(runtime_path) as f:
            runtime_code = f.read()

        # Second pass: generate program code
        self.lines = []
        self._emit("// ============================================================================")
        self._emit("// Generated by Logica JS Transpiler")
        self._emit("// A Programming Language for Human Logic")
        self._emit("// ============================================================================")
        self._emit("")
        self._emit("(function() {")
        self.indent += 1

        self._emit("const _mary = new Mary();")
        self._emit("const _ctx = new Context(_mary);")
        self._emit("")

        for stmt in ast.statements:
            self._transpile_statement(stmt)

        # Summary footer
        self._emit("")
        self._emit("// ── Summary ──")
        self._emit("console.log();")
        self._emit('console.log("  ---");')
        self._emit('const _total = _mary.ledgerCount(0);')
        self._emit('const _intact = _mary.ledgerVerify();')
        self._emit('console.log("  ledger: " + _total + " entries, integrity: " + (_intact ? "VALID" : "BROKEN"));')
        self._emit('console.log("  speakers: " + JSON.stringify(Object.keys(_ctx.speakers)));')
        self._emit('console.log("  ---");')

        self.indent -= 1
        self._emit("})();")

        return runtime_code + "\n\n" + "\n".join(self.lines) + "\n"

    # ── Code Emission ────────────────────────────────────────────────

    def _emit(self, line):
        """Emit a line of JS code at the current indentation."""
        if line == "":
            self.lines.append("")
        else:
            self.lines.append("    " * self.indent + line)

    # ── Statement Transpilation ──────────────────────────────────────

    def _transpile_statement(self, stmt):
        """Transpile a single AST statement to JavaScript."""
        if isinstance(stmt, SpeakerDecl):
            self._emit(f'_ctx.createSpeaker({json.dumps(stmt.name)});')

        elif isinstance(stmt, AsBlock):
            self._transpile_as_block(stmt)

        elif isinstance(stmt, LetStatement):
            self._transpile_let(stmt)

        elif isinstance(stmt, SpeakStatement):
            self._transpile_speak(stmt)

        elif isinstance(stmt, WhenBlock):
            self._transpile_when(stmt)

        elif isinstance(stmt, IfStatement):
            self._transpile_if(stmt)

        elif isinstance(stmt, WhileLoop):
            self._transpile_while(stmt)

        elif isinstance(stmt, FnDecl):
            self._transpile_fn(stmt)

        elif isinstance(stmt, ReturnStatement):
            if stmt.value:
                self._emit(f"return {self._expr(stmt.value)};")
            else:
                self._emit("return;")

        elif isinstance(stmt, RequestStatement):
            action = self._expr(stmt.action)
            self._emit(f'_ctx.requestTo({json.dumps(stmt.target)}, String({action}));')

        elif isinstance(stmt, RespondStatement):
            self._emit(f'_ctx.respondTo({"true" if stmt.accept else "false"});')

        elif isinstance(stmt, InspectStatement):
            self._transpile_inspect(stmt)

        elif isinstance(stmt, HistoryStatement):
            self._transpile_history(stmt)

        elif isinstance(stmt, LedgerStatement):
            if stmt.count:
                self._emit(f"_ctx.ledgerRead({self._expr(stmt.count)});")
            else:
                self._emit("_ctx.ledgerRead();")

        elif isinstance(stmt, VerifyStatement):
            self._emit("_ctx.verifyLedger();")

        elif isinstance(stmt, SealStatement):
            self._emit(f'_ctx.seal({json.dumps(stmt.target)});')

        elif isinstance(stmt, PassStatement):
            self._emit("/* pass */")

        elif isinstance(stmt, FailStatement):
            if stmt.reason:
                self._emit(f"throw new Error(String({self._expr(stmt.reason)}));")
            else:
                self._emit('throw new Error("explicit fail");')

        elif isinstance(stmt, ExpressionStatement):
            self._emit(f"{self._expr(stmt.expression)};")

        elif isinstance(stmt, WorldDecl):
            self._emit(f'console.log("  [" + _ctx.currentSpeaker + "] world created: {stmt.name}");')

    # ── Block Transpilation ──────────────────────────────────────────

    def _transpile_as_block(self, stmt):
        """Transpile 'as Speaker { ... }' block."""
        prev = self.current_speaker
        self.current_speaker = stmt.speaker_name
        self._emit("")
        self._emit(f"// as {stmt.speaker_name}")
        self._emit(f'_ctx.setSpeaker({json.dumps(stmt.speaker_name)});')

        for s in stmt.body:
            self._transpile_statement(s)

        self.current_speaker = prev
        if prev:
            self._emit(f'_ctx.setSpeaker({json.dumps(prev)});')
        else:
            self._emit("_ctx.setSpeaker(null);")

    def _transpile_let(self, stmt):
        """Transpile 'let name = expr'."""
        value_js = self._expr(stmt.value)
        self._emit(f'_ctx.write({json.dumps(stmt.name)}, {value_js});')

    def _transpile_speak(self, stmt):
        """Transpile 'speak expr'."""
        value_js = self._expr(stmt.value)
        self._emit(f"_ctx.speak({value_js});")

    def _transpile_when(self, stmt):
        """
        Transpile three-valued when/otherwise/broken block.

        when condition {
            ... active path ...
        } otherwise {
            ... inactive path ...
        } broken {
            ... broken path ...
        }
        """
        cond_js = self._expr(stmt.condition)
        self._emit("// when block (three-valued)")
        self._emit("{")
        self.indent += 1

        self._emit("let _conditionMet;")
        self._emit("try {")
        self.indent += 1
        self._emit(f"_conditionMet = Boolean({cond_js});")
        self.indent -= 1
        self._emit("} catch (_e) {")
        self.indent += 1
        self._emit("_conditionMet = null; // broken")
        self.indent -= 1
        self._emit("}")

        self._emit("if (_conditionMet === true) {")
        self.indent += 1
        self._emit("try {")
        self.indent += 1
        for s in stmt.body:
            self._transpile_statement(s)
        self.indent -= 1
        self._emit("} catch (_e) {")
        self.indent += 1
        self._emit("// broken path — action failed")
        for s in stmt.broken_body:
            self._transpile_statement(s)
        self.indent -= 1
        self._emit("}")
        self.indent -= 1

        self._emit("} else if (_conditionMet === false) {")
        self.indent += 1
        for s in stmt.otherwise_body:
            self._transpile_statement(s)
        self.indent -= 1

        self._emit("} else {")
        self.indent += 1
        self._emit("// broken — condition evaluation failed")
        for s in stmt.broken_body:
            self._transpile_statement(s)
        self.indent -= 1
        self._emit("}")

        self.indent -= 1
        self._emit("}")

    def _transpile_if(self, stmt):
        """Transpile if/elif/else."""
        cond_js = self._expr(stmt.condition)
        self._emit(f"if ({cond_js}) {{")
        self.indent += 1
        for s in stmt.body:
            self._transpile_statement(s)
        self.indent -= 1

        for clause in stmt.elif_clauses:
            clause_cond = self._expr(clause.condition)
            self._emit(f"}} else if ({clause_cond}) {{")
            self.indent += 1
            for s in clause.body:
                self._transpile_statement(s)
            self.indent -= 1

        if stmt.else_body:
            self._emit("} else {")
            self.indent += 1
            for s in stmt.else_body:
                self._transpile_statement(s)
            self.indent -= 1

        self._emit("}")

    def _transpile_while(self, stmt):
        """
        Transpile bounded while loop.

        Axiom 9: Every loop must have a max bound.
        """
        cond_js = self._expr(stmt.condition)
        max_js = self._expr(stmt.max_iterations) if stmt.max_iterations else "10000"

        self._emit("{")
        self.indent += 1
        self._emit(f"const _maxIter = {max_js};")
        self._emit("let _count = 0;")
        self._emit(f"while ({cond_js} && _count < _maxIter) {{")
        self.indent += 1
        for s in stmt.body:
            self._transpile_statement(s)
        self._emit("_count++;")
        self.indent -= 1
        self._emit("}")
        self._emit("if (_count >= _maxIter) {")
        self.indent += 1
        self._emit('throw new Error("loop exceeded max " + _maxIter + " iterations");')
        self.indent -= 1
        self._emit("}")
        self.indent -= 1
        self._emit("}")

    def _transpile_fn(self, stmt):
        """
        Transpile function declaration.

        Functions are owned by the speaker who defines them.
        The body runs with a local scope for parameters.
        """
        speaker = self.current_speaker
        params_binding = ", ".join(
            f'{json.dumps(p)}: args[{i}]' for i, p in enumerate(stmt.params)
        )

        self._emit(f'_ctx.defineFunction({json.dumps(speaker)}, {json.dumps(stmt.name)}, function(args) {{')
        self.indent += 1
        self._emit(f"_ctx.pushScope({{{params_binding}}});")
        self._emit("try {")
        self.indent += 1

        for s in stmt.body:
            self._transpile_statement(s)

        self.indent -= 1
        self._emit("} finally {")
        self.indent += 1
        self._emit("_ctx.popScope();")
        self.indent -= 1
        self._emit("}")
        self.indent -= 1
        self._emit("});")

    def _transpile_inspect(self, stmt):
        """Transpile inspect statement."""
        target = stmt.target
        if isinstance(target, Identifier):
            self._emit(f'_ctx.inspect({json.dumps(target.name)});')
        elif isinstance(target, MemberAccess) and isinstance(target.object, Identifier):
            self._emit(f'_ctx.inspect([{json.dumps(target.object.name)}, {json.dumps(target.member)}]);')
        else:
            self._emit(f"_ctx.inspect(String({self._expr(target)}));")

    def _transpile_history(self, stmt):
        """Transpile history statement."""
        target = stmt.target
        if isinstance(target, MemberAccess) and isinstance(target.object, Identifier):
            self._emit(f'_ctx.history({json.dumps(target.object.name)}, {json.dumps(target.member)});')
        elif isinstance(target, Identifier):
            self._emit(f'_ctx.history(_ctx.currentSpeaker, {json.dumps(target.name)});')

    # ── Expression Transpilation ─────────────────────────────────────

    def _expr(self, node) -> str:
        """Transpile an AST expression node to a JavaScript expression string."""
        if node is None:
            return "null"

        if isinstance(node, IntegerLiteral):
            return str(node.value)

        if isinstance(node, FloatLiteral):
            return str(node.value)

        if isinstance(node, StringLiteral):
            return json.dumps(node.value)

        if isinstance(node, BooleanLiteral):
            return "true" if node.value else "false"

        if isinstance(node, NoneLiteral):
            return "null"

        if isinstance(node, StatusLiteral):
            return json.dumps(node.value)

        if isinstance(node, Identifier):
            return f'_ctx.resolve({json.dumps(node.name)})'

        if isinstance(node, MemberAccess):
            return self._expr_member_access(node)

        if isinstance(node, BinaryOp):
            return self._expr_binary(node)

        if isinstance(node, UnaryOp):
            return self._expr_unary(node)

        if isinstance(node, FnCall):
            return self._expr_fn_call(node)

        if isinstance(node, ReadExpr):
            return self._expr(node.target)

        if isinstance(node, IndexAccess):
            obj = self._expr(node.object)
            idx = self._expr(node.index)
            return f"({obj})[{idx}]"

        if isinstance(node, ConditionalExpr):
            cond = self._expr(node.condition)
            true_val = self._expr(node.true_value)
            false_val = self._expr(node.false_value)
            return f"({cond} ? {true_val} : {false_val})"

        return "null"

    def _expr_member_access(self, node):
        """Transpile member access — speaker.variable or object.member."""
        if isinstance(node.object, Identifier):
            name = node.object.name
            if name in self.declared_speakers:
                # Speaker variable access: read from that speaker's partition
                return f'_ctx.readFrom({json.dumps(name)}, {json.dumps(node.member)})'
            else:
                # Generic object member access with null safety
                obj = self._expr(node.object)
                return f'({obj} != null ? ({obj})[{json.dumps(node.member)}] : null)'
        # Nested member access
        obj = self._expr(node.object)
        return f'({obj})[{json.dumps(node.member)}]'

    def _expr_binary(self, node):
        """Transpile binary operation."""
        left = self._expr(node.left)
        right = self._expr(node.right)
        op = node.op

        # Division by zero returns null (matches Logica semantics)
        if op == '/':
            return f"({right} !== 0 ? {left} / {right} : null)"
        if op == '%':
            return f"({right} !== 0 ? {left} % {right} : null)"

        js_ops = {
            '+': '+', '-': '-', '*': '*',
            '==': '===', '!=': '!==',
            '<': '<', '>': '>', '<=': '<=', '>=': '>=',
            'and': '&&', 'or': '||',
        }

        js_op = js_ops.get(op, op)
        return f"({left} {js_op} {right})"

    def _expr_unary(self, node):
        """Transpile unary operation."""
        operand = self._expr(node.operand)
        if node.op == 'not':
            return f"(!{operand})"
        return f"({node.op}{operand})"

    def _expr_fn_call(self, node):
        """Transpile function call."""
        if isinstance(node.function, Identifier):
            fn_name = node.function.name
            args_js = ", ".join(self._expr(a) for a in node.args)
            return f'_ctx.callFunction({json.dumps(fn_name)}, [{args_js}])'

        if isinstance(node.function, MemberAccess):
            if isinstance(node.function.object, Identifier):
                speaker = node.function.object.name
                fn_name = node.function.member
                qualified = f"{speaker}.{fn_name}"
                args_js = ", ".join(self._expr(a) for a in node.args)
                return f'_ctx.callFunction({json.dumps(qualified)}, [{args_js}])'

        # Fallback: generic call
        fn_js = self._expr(node.function)
        args_js = ", ".join(self._expr(a) for a in node.args)
        return f"({fn_js})({args_js})"
